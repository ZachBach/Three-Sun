{"id":"js/shader/fragment.glsl","dependencies":[{"name":"C:\\Users\\auern\\sun\\package.json","includedInParent":true,"mtime":1633399531787}],"generated":{"js":"module.exports = \"#define GLSLIFY 1\\nuniform float time;\\nuniform float progress;\\nuniform sampler2D texture1;\\nuniform vec4 resolution;\\nvarying vec2 vUv;\\nvarying vec3 vPosition;\\nfloat PI=3.141592653589793238;\\n\\n//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec4 mod289(vec4 x){\\n\\treturn x-floor(x*(1./289.))*289.;\\n}\\n\\nfloat mod289(float x){\\n\\treturn x-floor(x*(1./289.))*289.;\\n}\\n\\nvec4 permute(vec4 x){\\n\\treturn mod289(((x*34.)+1.)*x);\\n}\\n\\nfloat permute(float x){\\n\\treturn mod289(((x*34.)+1.)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n\\treturn 1.79284291400159-.85373472095314*r;\\n}\\n\\nfloat taylorInvSqrt(float r)\\n{\\n\\treturn 1.79284291400159-.85373472095314*r;\\n}\\n\\nvec4 grad4(float j,vec4 ip)\\n{\\n\\tconst vec4 ones=vec4(1.,1.,1.,-1.);\\n\\tvec4 p,s;\\n\\t\\n\\tp.xyz=floor(fract(vec3(j)*ip.xyz)*7.)*ip.z-1.;\\n\\tp.w=1.5-dot(abs(p.xyz),ones.xyz);\\n\\ts=vec4(lessThan(p,vec4(0.)));\\n\\tp.xyz=p.xyz+(s.xyz*2.-1.)*s.www;\\n\\t\\n\\treturn p;\\n}\\n\\n// (sqrt(5) - 1)/4 = F4, used once below\\n#define F4.309016994374947451\\n\\nfloat snoise(vec4 v)\\n{\\n\\tconst vec4 C=vec4(.138196601125011,// (5 - sqrt(5))/20  G4\\n\\t.276393202250021,// 2 * G4\\n\\t.414589803375032,// 3 * G4\\n-.447213595499958);// -1 + 4 * G4\\n\\n// First corner\\nvec4 i=floor(v+dot(v,vec4(F4)));\\nvec4 x0=v-i+dot(i,C.xxxx);\\n\\n// Other corners\\n\\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\\nvec4 i0;\\nvec3 isX=step(x0.yzw,x0.xxx);\\nvec3 isYZ=step(x0.zww,x0.yyz);\\n//  i0.x = dot( isX, vec3( 1.0 ) );\\ni0.x=isX.x+isX.y+isX.z;\\ni0.yzw=1.-isX;\\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\\ni0.y+=isYZ.x+isYZ.y;\\ni0.zw+=1.-isYZ.xy;\\ni0.z+=isYZ.z;\\ni0.w+=1.-isYZ.z;\\n\\n// i0 now contains the unique values 0,1,2,3 in each channel\\nvec4 i3=clamp(i0,0.,1.);\\nvec4 i2=clamp(i0-1.,0.,1.);\\nvec4 i1=clamp(i0-2.,0.,1.);\\n\\n//  x0 = x0 - 0.0 + 0.0 * C.xxxx\\n//  x1 = x0 - i1  + 1.0 * C.xxxx\\n//  x2 = x0 - i2  + 2.0 * C.xxxx\\n//  x3 = x0 - i3  + 3.0 * C.xxxx\\n//  x4 = x0 - 1.0 + 4.0 * C.xxxx\\nvec4 x1=x0-i1+C.xxxx;\\nvec4 x2=x0-i2+C.yyyy;\\nvec4 x3=x0-i3+C.zzzz;\\nvec4 x4=x0+C.wwww;\\n\\n// Permutations\\ni=mod289(i);\\nfloat j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);\\nvec4 j1=permute(permute(permute(permute(\\n\\t\\t\\t\\ti.w+vec4(i1.w,i2.w,i3.w,1.))\\n\\t\\t\\t\\t+i.z+vec4(i1.z,i2.z,i3.z,1.))\\n\\t\\t\\t\\t+i.y+vec4(i1.y,i2.y,i3.y,1.))\\n\\t\\t\\t\\t+i.x+vec4(i1.x,i2.x,i3.x,1.));\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\\n\\t\\t\\t\\t// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\\n\\t\\t\\t\\tvec4 ip=vec4(1./294.,1./49.,1./7.,0.);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tvec4 p0=grad4(j0,ip);\\n\\t\\t\\t\\tvec4 p1=grad4(j1.x,ip);\\n\\t\\t\\t\\tvec4 p2=grad4(j1.y,ip);\\n\\t\\t\\t\\tvec4 p3=grad4(j1.z,ip);\\n\\t\\t\\t\\tvec4 p4=grad4(j1.w,ip);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Normalise gradients\\n\\t\\t\\t\\tvec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));\\n\\t\\t\\t\\tp0*=norm.x;\\n\\t\\t\\t\\tp1*=norm.y;\\n\\t\\t\\t\\tp2*=norm.z;\\n\\t\\t\\t\\tp3*=norm.w;\\n\\t\\t\\t\\tp4*=taylorInvSqrt(dot(p4,p4));\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Mix contributions from the five corners\\n\\t\\t\\t\\tvec3 m0=max(.6-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.);\\n\\t\\t\\t\\tvec2 m1=max(.6-vec2(dot(x3,x3),dot(x4,x4)),0.);\\n\\t\\t\\t\\tm0=m0*m0;\\n\\t\\t\\t\\tm1=m1*m1;\\n\\t\\t\\t\\treturn 49.*(dot(m0*m0,vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2)))\\n\\t\\t\\t\\t+dot(m1*m1,vec2(dot(p3,x3),dot(p4,x4))));\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// 6 \\n\\n\\t\\tfloat fbm(vec4 p){\\n\\t\\t\\t\\tfloat sum=0.;\\n\\t\\t\\t\\tfloat amp=1.;\\n\\t\\t\\t\\tfloat scale=1.;\\n\\t\\t\\t\\tfor(int i=0;i<6;i++){\\n\\t\\t\\t\\t\\tsum+=snoise(p*scale)*amp;\\n\\t\\t\\t\\t\\tp.w+=100.;\\n\\t\\t\\t\\t\\tamp *= 0.9;\\n\\t\\t\\t\\t\\tscale *=2.;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn sum;\\n\\t\\t\\t}\\n\\n\\t\\t\\t\\n\\n\\t\\t\\t\\n\\t\\t\\tvoid main(){\\n\\t\\t\\t\\t// vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);\\n\\t\\t\\t\\t\\tvec4 p = vec4(vPosition*4.,time*0.0005);\\n\\t\\t\\t\\t\\tfloat noisy = fbm(p);\\n\\t\\t\\t\\t\\tvec4 p1 = vec4(vPosition*2.,time*0.005);\\n\\t\\t\\t\\t\\tfloat spots = max(snoise(p1),0.);\\n\\t\\t\\t\\t\\tgl_FragColor = vec4(noisy);\\n\\t\\t\\t\\t\\t// gl_FragColor=vec4(vPosition,1.);\\n\\t\\t\\t\\t\\tgl_FragColor *= mix(1.,spots,0.7);\\n\\t\\t\\t}\";"},"sourceMaps":{"js":{"mappings":[{"name":"module","generated":{"line":1,"column":0},"source":"js/shader/fragment.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":6},"source":"js/shader/fragment.glsl","original":{"line":1,"column":6}},{"name":"exports","generated":{"line":1,"column":7},"source":"js/shader/fragment.glsl","original":{"line":1,"column":7}},{"generated":{"line":1,"column":14},"source":"js/shader/fragment.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":17},"source":"js/shader/fragment.glsl","original":{"line":1,"column":15}},{"generated":{"line":1,"column":4442},"source":"js/shader/fragment.glsl","original":{"line":1,"column":0}}],"sources":{"js/shader/fragment.glsl":"module.exports=\"#define GLSLIFY 1\\nuniform float time;\\nuniform float progress;\\nuniform sampler2D texture1;\\nuniform vec4 resolution;\\nvarying vec2 vUv;\\nvarying vec3 vPosition;\\nfloat PI=3.141592653589793238;\\n\\n//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec4 mod289(vec4 x){\\n\\treturn x-floor(x*(1./289.))*289.;\\n}\\n\\nfloat mod289(float x){\\n\\treturn x-floor(x*(1./289.))*289.;\\n}\\n\\nvec4 permute(vec4 x){\\n\\treturn mod289(((x*34.)+1.)*x);\\n}\\n\\nfloat permute(float x){\\n\\treturn mod289(((x*34.)+1.)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n\\treturn 1.79284291400159-.85373472095314*r;\\n}\\n\\nfloat taylorInvSqrt(float r)\\n{\\n\\treturn 1.79284291400159-.85373472095314*r;\\n}\\n\\nvec4 grad4(float j,vec4 ip)\\n{\\n\\tconst vec4 ones=vec4(1.,1.,1.,-1.);\\n\\tvec4 p,s;\\n\\t\\n\\tp.xyz=floor(fract(vec3(j)*ip.xyz)*7.)*ip.z-1.;\\n\\tp.w=1.5-dot(abs(p.xyz),ones.xyz);\\n\\ts=vec4(lessThan(p,vec4(0.)));\\n\\tp.xyz=p.xyz+(s.xyz*2.-1.)*s.www;\\n\\t\\n\\treturn p;\\n}\\n\\n// (sqrt(5) - 1)/4 = F4, used once below\\n#define F4.309016994374947451\\n\\nfloat snoise(vec4 v)\\n{\\n\\tconst vec4 C=vec4(.138196601125011,// (5 - sqrt(5))/20  G4\\n\\t.276393202250021,// 2 * G4\\n\\t.414589803375032,// 3 * G4\\n-.447213595499958);// -1 + 4 * G4\\n\\n// First corner\\nvec4 i=floor(v+dot(v,vec4(F4)));\\nvec4 x0=v-i+dot(i,C.xxxx);\\n\\n// Other corners\\n\\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\\nvec4 i0;\\nvec3 isX=step(x0.yzw,x0.xxx);\\nvec3 isYZ=step(x0.zww,x0.yyz);\\n//  i0.x = dot( isX, vec3( 1.0 ) );\\ni0.x=isX.x+isX.y+isX.z;\\ni0.yzw=1.-isX;\\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\\ni0.y+=isYZ.x+isYZ.y;\\ni0.zw+=1.-isYZ.xy;\\ni0.z+=isYZ.z;\\ni0.w+=1.-isYZ.z;\\n\\n// i0 now contains the unique values 0,1,2,3 in each channel\\nvec4 i3=clamp(i0,0.,1.);\\nvec4 i2=clamp(i0-1.,0.,1.);\\nvec4 i1=clamp(i0-2.,0.,1.);\\n\\n//  x0 = x0 - 0.0 + 0.0 * C.xxxx\\n//  x1 = x0 - i1  + 1.0 * C.xxxx\\n//  x2 = x0 - i2  + 2.0 * C.xxxx\\n//  x3 = x0 - i3  + 3.0 * C.xxxx\\n//  x4 = x0 - 1.0 + 4.0 * C.xxxx\\nvec4 x1=x0-i1+C.xxxx;\\nvec4 x2=x0-i2+C.yyyy;\\nvec4 x3=x0-i3+C.zzzz;\\nvec4 x4=x0+C.wwww;\\n\\n// Permutations\\ni=mod289(i);\\nfloat j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);\\nvec4 j1=permute(permute(permute(permute(\\n\\t\\t\\t\\ti.w+vec4(i1.w,i2.w,i3.w,1.))\\n\\t\\t\\t\\t+i.z+vec4(i1.z,i2.z,i3.z,1.))\\n\\t\\t\\t\\t+i.y+vec4(i1.y,i2.y,i3.y,1.))\\n\\t\\t\\t\\t+i.x+vec4(i1.x,i2.x,i3.x,1.));\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\\n\\t\\t\\t\\t// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\\n\\t\\t\\t\\tvec4 ip=vec4(1./294.,1./49.,1./7.,0.);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tvec4 p0=grad4(j0,ip);\\n\\t\\t\\t\\tvec4 p1=grad4(j1.x,ip);\\n\\t\\t\\t\\tvec4 p2=grad4(j1.y,ip);\\n\\t\\t\\t\\tvec4 p3=grad4(j1.z,ip);\\n\\t\\t\\t\\tvec4 p4=grad4(j1.w,ip);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Normalise gradients\\n\\t\\t\\t\\tvec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));\\n\\t\\t\\t\\tp0*=norm.x;\\n\\t\\t\\t\\tp1*=norm.y;\\n\\t\\t\\t\\tp2*=norm.z;\\n\\t\\t\\t\\tp3*=norm.w;\\n\\t\\t\\t\\tp4*=taylorInvSqrt(dot(p4,p4));\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Mix contributions from the five corners\\n\\t\\t\\t\\tvec3 m0=max(.6-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.);\\n\\t\\t\\t\\tvec2 m1=max(.6-vec2(dot(x3,x3),dot(x4,x4)),0.);\\n\\t\\t\\t\\tm0=m0*m0;\\n\\t\\t\\t\\tm1=m1*m1;\\n\\t\\t\\t\\treturn 49.*(dot(m0*m0,vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2)))\\n\\t\\t\\t\\t+dot(m1*m1,vec2(dot(p3,x3),dot(p4,x4))));\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// 6 \\n\\n\\t\\tfloat fbm(vec4 p){\\n\\t\\t\\t\\tfloat sum=0.;\\n\\t\\t\\t\\tfloat amp=1.;\\n\\t\\t\\t\\tfloat scale=1.;\\n\\t\\t\\t\\tfor(int i=0;i<6;i++){\\n\\t\\t\\t\\t\\tsum+=snoise(p*scale)*amp;\\n\\t\\t\\t\\t\\tp.w+=100.;\\n\\t\\t\\t\\t\\tamp *= 0.9;\\n\\t\\t\\t\\t\\tscale *=2.;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn sum;\\n\\t\\t\\t}\\n\\n\\t\\t\\t\\n\\n\\t\\t\\t\\n\\t\\t\\tvoid main(){\\n\\t\\t\\t\\t// vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);\\n\\t\\t\\t\\t\\tvec4 p = vec4(vPosition*4.,time*0.0005);\\n\\t\\t\\t\\t\\tfloat noisy = fbm(p);\\n\\t\\t\\t\\t\\tvec4 p1 = vec4(vPosition*2.,time*0.005);\\n\\t\\t\\t\\t\\tfloat spots = max(snoise(p1),0.);\\n\\t\\t\\t\\t\\tgl_FragColor = vec4(noisy);\\n\\t\\t\\t\\t\\t// gl_FragColor=vec4(vPosition,1.);\\n\\t\\t\\t\\t\\tgl_FragColor *= mix(1.,spots,0.7);\\n\\t\\t\\t}\";"},"lineCount":null}},"error":null,"hash":"f63e15c4a37346f7461d35a1e01da6a4","cacheData":{"env":{}}}